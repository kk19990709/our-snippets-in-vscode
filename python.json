{
    // Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    "CREATE_FILE_ARGS": {
        "prefix": "CREATE_FILE_ARGS",
        "body": [
            "# region argparse",
            "import argparse",
            "",
            "parser = argparse.ArgumentParser()",
            "# hardware",
            "parser.add_argument('--gpu', dest='gpu', nargs='+', type=int, default=[0])",
            "# preprocess",
            "parser.add_argument('--sl', dest='seq_len', type=int, default=200)",
            "# dataset",
            "parser.add_argument('--md', dest='makedata', action='store_true', default=False)",
            "# network structure",
            "parser.add_argument('--mdl', dest='model', type=str, default='GRU')",
            "parser.add_argument('--dr', dest='dropout_rate', type=float, default=0.1)",
            "parser.add_argument('--hs', dest='hidden_size', type=int, default=32)",
            "# optimizer & criterion",
            "parser.add_argument('--op', dest='optimizer', type=str, default='CrossEntropyLoss')",
            "parser.add_argument('--cr', dest='criterion', type=str, default='Adam')",
            "parser.add_argument('--lr', dest='learning_rate', type=float, default=0.004)",
            "# train",
            "parser.add_argument('--nt', dest='notrain', action='store_true', default=False)",
            "parser.add_argument('--ne', dest='num_epochs', type=int, default=50)",
            "parser.add_argument('--bs', dest='batch_size', type=int, default=32)",
            "parser.add_argument('--nl', dest='num_layers', type=int, default=2)",
            "",
            "# opt = parser.parse_args(args=['--nt'])",
            "opt = parser.parse_args()",
            "",
            "print(vars(opt))",
            "# endregion",
            "",
            "",
            "# region consts",
            "\"\"\"",
            "VOCAB_SIZE = 300",
            "NUM_CLASS = 8",
            "\"\"\"",
            "# endregion",
            ""
        ],
        "description": "CREATE_FILE_ARGS"
    },
    "CREATE_FILE_MAIN": {
        "prefix": "CREATE_FILE_MAIN",
        "body": [
            "# %%",
            "# region import",
            "",
            "# endregion",
            "",
            "# %%",
            "# region data",
            "",
            "# endregion",
            "",
            "# %%",
            "# region preprocess",
            "",
            "# endregion",
            "",
            "# %%",
            "# region dataset & dataloader",
            "",
            "# endregion",
            "",
            "# %%",
            "# region model",
            "",
            "# endregion",
            "",
            "# %%",
            "# region optimizer & criterion",
            "",
            "# endregion",
            "",
            "# %%",
            "# region train & valid",
            "",
            "# endregion",
            "",
            "# %%",
            "# region test",
            "",
            "# endregion",
            "",
            "# %%",
            "# region visualize",
            "",
            "# endregion",
            "",
            "# %%",
            "# region anomaly detection",
            "",
            "# endregion"
        ],
        "description": "CREATE_FILE_MAIN"
    },
    "IMPORT": {
        "prefix": "IMPORT",
        "body": [
            "# outer import",
            "import os",
            "import nni",
            "import json",
            "import logging",
            "import numpy as np",
            "import pandas as pd",
            "import nltk",
            "import torch",
            "import torch.nn as nn",
            "import torch.nn.functional as F",
            "from tqdm import tqdm, trange",
            "from nni.utils import merge_parameter",
            "from torchtext.data import Field, Example, Dataset, BucketIterator",
            "# inner import",
            "from args import *"
        ],
        "description": "IMPORT"
    },
    "DATA": {
        "prefix": "DATA",
        "body": [
            "# 1 checkpoint",
            "if opt.minidata:",
            "    checkpoint = './dataset_mini/data.pkl'",
            "elif opt.largedata:",
            "    checkpoint = './dataset_large/data.pkl'",
            "else:",
            "    checkpoint = './dataset/data.pkl'",
            "# 2 data",
            "if opt.makedata:",
            "    with open('./data/${1:data.txt}', 'r', encoding='utf-8') as f:",
            "        data = json.load(f)",
            "    data = pd.json_normalize(data.values(), max_level=0)",
            "",
            "    if opt.minidata:",
            "        data = data.head()",
            "    elif opt.largedata:",
            "        # process",
            "        pass",
            "    else: # normal",
            "        pass"
        ],
        "description": "DATA"
    },
    "binary_search": {
        "prefix": "binary_search",
        "body": [
            "def binary_search(values, target):",
            "    \"\"\"",
            "    要求：有序列表",
            "    l, r分别为可以取到的最小值，最大值",
            "    如果表中存在该键    binary_search()应该返回表中小于它的键的数量，也就是该键的位置；",
            "    如果表中不存在该键  binary_search()还是应该返回表中小于它的键的数量，也就是该键稍大的数值所在的位置。",
            "    \"\"\"",
            "    l = 0",
            "    r = len(values) - 1",
            "    while l <= r:",
            "        m = (l + r) // 2",
            "        if target < values[m]:",
            "            r = m - 1",
            "        elif target > values[m]:",
            "            l = m + 1",
            "        else:",
            "            return m",
            "    return l  # 未找到"
        ],
        "description": "binary_search"
    },
    "Composite": {
        "prefix": "Composite",
        "body": [
            "from __future__ import annotations",
            "from abc import ABC, abstractmethod",
            "from typing import List",
            "",
            "",
            "class Component(ABC):",
            "    \"\"\"",
            "    组件：",
            "    接口描述了树中简单项目和复杂项目所共有的操作。",
            "    \"\"\"",
            "",
            "    @property",
            "    def parent(self) -> Component:",
            "        return self._parent",
            "",
            "    @parent.setter",
            "    def parent(self, parent: Component):",
            "        \"\"\"",
            "        基本组件可以声明一个接口，用于在树结构中设置和访问组件的父级。",
            "        它还可以为这些方法提供一些默认实现。",
            "        \"\"\"",
            "        self._parent = parent",
            "",
            "    \"\"\"",
            "    在某些情况下，在基本组件类中定义子管理操作是有益的。",
            "    这样，即使在对象树组装期间，也不需要向客户机代码公开任何具体的组件类。",
            "    缺点是这些方法对于叶级组件来说是空的。",
            "    \"\"\"",
            "    def add(self, component: Component) -> None:",
            "        pass",
            "",
            "    def remove(self, component: Component) -> None:",
            "        pass",
            "",
            "    def is_composite(self) -> bool:",
            "        \"\"\"",
            "        您可以提供一个方法，让客户机代码判断组件是否可以承载子组件。",
            "        \"\"\"",
            "        return False",
            "",
            "    @abstractmethod",
            "    def operation(self) -> str:",
            "        \"\"\"",
            "        基本组件可以自己实现一些默认行为或者将其留给具体的类设定为抽象类。",
            "        \"\"\"",
            "        pass",
            "",
            "",
            "class Leaf(Component):",
            "    \"\"\"",
            "    叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。",
            "    叶节点对象通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。",
            "    \"\"\"",
            "    def operation(self) -> str:",
            "        return \"Leaf\"",
            "",
            "",
            "class Composite(Component):",
            "    \"\"\"",
            "    组合是包含叶节点或其他组合等子项目的单位。 ",
            "    容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。",
            "    通常，组合对象将实际工作委托给其子对象，然后\"汇总\"结果。",
            "    \"\"\"",
            "    def __init__(self) -> None:",
            "        self._children: List[Component] = []",
            "",
            "    \"\"\"",
            "    组合对象可以在其子列表中添加或删除其他子项目。",
            "    \"\"\"",
            "    def add(self, component: Component) -> None:",
            "        self._children.append(component)",
            "        component.parent = self",
            "",
            "    def remove(self, component: Component) -> None:",
            "        self._children.remove(component)",
            "        component.parent = None",
            "",
            "    def is_composite(self) -> bool:",
            "        return True",
            "",
            "    def operation(self) -> str:",
            "        \"\"\"",
            "        组合以特定的方式执行其主逻辑。",
            "        它递归地遍历它的所有子项目，收集并汇总它们的结果。",
            "        由于组合的子项目将这些调用传递给其子子项目等等，因此将遍历整个对象树。",
            "        \"\"\"",
            "        results = []",
            "        for child in self._children:",
            "            results.append(child.operation())",
            "        return f\"Branch({'+'.join(results)})\"",
            "",
            "",
            "def client_code(component: Component) -> None:",
            "    \"\"\"",
            "    客户机代码通过基本接口与所有组件一起工作。",
            "    \"\"\"",
            "    print(f\"RESULT: {component.operation()}\", end=\"\")",
            "",
            "",
            "def client_code2(component1: Component, component2: Component) -> None:",
            "    \"\"\"",
            "    由于子组件管理操作是在基本组件类中声明的，",
            "    因此客户机代码可以处理任何简单或复杂的组件，而不依赖于它们的具体类。",
            "    \"\"\"",
            "    if component1.is_composite():",
            "        component1.add(component2)",
            "    print(f\"RESULT: {component1.operation()}\", end=\"\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    # This way the client code can support the simple leaf components...",
            "    simple = Leaf()",
            "    print(\"Client: I've got a simple component:\")",
            "    client_code(simple)",
            "    print(\"\\n\")",
            "",
            "    # ...as well as the complex composites.",
            "    tree = Composite()",
            "",
            "    branch1 = Composite()",
            "    branch1.add(Leaf())",
            "    branch1.add(Leaf())",
            "",
            "    branch2 = Composite()",
            "    branch2.add(Leaf())",
            "",
            "    tree.add(branch1)",
            "    tree.add(branch2)",
            "",
            "    print(\"Client: Now I've got a composite tree:\")",
            "    client_code(tree)",
            "    print(\"\\n\")",
            "",
            "    print(\"Client: I don't need to check the components classes even when managing the tree:\")",
            "    client_code2(tree, simple)",
            ""
        ],
        "description": "Composite"
    }
}